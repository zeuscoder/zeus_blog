---
title: WEB：浏览器渲染机制
date: 2019-07-06 19:25:02
tags:
---

在不同浏览器下代码渲染的结果会存在一定的差异性，造成差异性的原因是**浏览器内核**的不同，浏览器内核决定了浏览器解释网页语法的方式。

<!-- more -->

而浏览器内核可以分为两部分：JS 引擎和**渲染引擎**（Layout Enfine 或 Rendering Engine）。

本文主要介绍渲染引擎，渲染引擎包括了 `HTML 解释器`、`CSS 解释器`、布局、网络、存储、图形、音视频、图片解码器等等零部件。

各浏览器对应的渲染引擎：

* IE：Trident
* Firefox：Gecko
* Chrome & Safari：**Webkit**

***

### 渲染过程

本文接下来会介绍 `webkit` 渲染引擎的渲染过程。

渲染过程：渲染引擎根据 HTML 文件描述构建响应的数学模型，调用浏览器各个零部件，从而将网页资源代码转换为图像结果：

![渲染过程](/images/web-render/render.png)

浏览器呈现网页的渲染过程，是由内核内部的功能模块相互配合协同工作进行的，我们需要关注以下几大功能模块：

* `HTML 解释器`：将 HTML 文档经过词法分析输出 `DOM` 树。
* `CSS 解释器`：解析 CSS 文档，生成样式规则，输出 `CSSOM` 树。
* `图层布局计算模块`：布局计算每个对象的精确位置和大小。
* `视图绘制模块`：进行具体节点的图像绘制，将像素渲染到屏幕上。
* `JavaScript 引擎`：编译执行 Javascript 代码。

每个页面的**首次渲染**都经历如下阶段：

![渲染过程解析](/images/web-render/parse.png)

* **解析 HTML**

在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。

* **计算样式**

浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。

* **计算图层布局**

页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。

* **绘制图层**

在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。

* **整合图层，得到页面**

最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。

![渲染过程解析](/images/web-render/tree.png)

**总结**：

基于上述流程，其实渲染过程就是： ① 首先基于 HTML 构建一个 DOM 树，② DOM 树与 CSS 解释器解析出的 CSSOM 相结合，③ 得到布局渲染树 Render Tree。④ 最后浏览器以布局渲染树（Layout）为蓝本，去计算布局并绘制（Paint）图像。

**之后每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它。**

***

### CSS 优化

明白了浏览器的渲染过程后，就可以基于渲染流程对 CSS 做优化了。

前置知识：**CSS 选择符是从右到左进行匹配的**。

性能提升方案：

* 避免使用通配符 `* {}`，只对需要用到的元素进行选择。
* 少用标签选择器，尽量用类选择器替代。
* 减少嵌套，后代选择器的开销是最高的。

### 加载优化

HTML、CSS 和 JS，都具有**阻塞渲染**的特性。因此，需要优化 CSS 和 JS 的加载顺序：

* CSS：将 `css` 放在 `head` 标签里（尽早）和启用 `CDN` 实现静态资源加载速度的优化（尽快）
* JS：给 `script` 标签添加 `async` / `defer` 标签

### DOM 优化

#### 减少 DOM 操作

> 把 DOM 和 Javascript 各自想象成一个岛屿，它们之间用收费桥梁连接。

JS 引擎和渲染引擎是**独立实现**的，当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了「`跨界交流`」。这跨界交流的实现依赖了桥接接口作为“桥梁”。

![操作 DOM](/images/web-render/dom.png)

每次操作 DOM （修改或是访问），都需要过桥收桥费。因此需要**减少操作 DOM**。（DOM Fragment）

#### 减少 DOM 修改

上述仅仅是「过桥」，过完桥，假如继续操作（修改 DOM），也是慢动作。

一旦对 DOM 进行修改，会引发外观（样式）上的改变时，就会触发**回流**或**重绘**，本质上是对 DOM 修改触发了渲染树（Render Tree）的变化所导致的：

![操作 DOM](/images/web-render/render-tree.png)

* 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。

* 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。

总结：**重绘不一定导致回流，回流一定会导致重绘**。尽可能减少 DOM 修改。

### 异步更新

详见 Vue 异步更新策略。

### 回流与重绘

关于回流与重绘，可以回顾下 DOM 优化时的描述。

避免回流和重绘的发生，最直接的做法就是**避免掉可能会引发回流与重绘的 DOM 操作**，首先找出可能会触发它们的**导火索**：

* 重绘：修改 `background`、`color`、`visibility` 等样式属性。
* 回流：① 修改 `width`、`height`、`padding`、`margin`、`left`、`top`、`border` 等几何属性。② 改变 DOM 树的结构：增删、移动节点。③ 获取一定特定属性的值：`offsetWidth`、`scrollWidth`、`clientWidth` 等，会触发**即时计算**。

建议：

* Transtion 动画：优先选择 `transform`，尽量不使用 height，width，padding，margin。
* 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）。
* 不要把节点的属性值放在一个循环里当成循环里的变量。
* 不要使用 `table` 布局，可能很小的一个小改动会造成整个 table 的重新布局。
* 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`。
* CSS 选择符从右往左匹配查找，避免节点层级过多。
* 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 `video` 标签来说，浏览器会自动将该节点变为图层。`will-change` 属性和 `video`、`iframe` 标签都可以把节点为图层

参考文章：

[前端性能优化原理与实践](https://juejin.im/book/5b936540f265da0a9624b04b/section/5b936540f265da0aec223b5d)

[浏览器渲染原理](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d)
